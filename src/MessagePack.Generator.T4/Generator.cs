// Copyright (c) All contributors. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.
#pragma warning disable IDE0057

namespace MessagePack.Generator.T4;

[Generator(LanguageNames.CSharp)]
public sealed partial class Generator : IIncrementalGenerator
{
    private const string AttributeSource = @"// <auto-generated />
namespace MessagePackCompiler;

[global::System.AttributeUsageAttribute(global::System.AttributeTargets.Class | global::System.AttributeTargets.Struct, AllowMultiple = false)]
internal sealed class T4Attribute : global::System.Attribute
{
    public T4Attribute(string path = """")
    {
    }
}

[global::System.AttributeUsageAttribute(global::System.AttributeTargets.Class | global::System.AttributeTargets.Struct, AllowMultiple = false)]
internal sealed class IndentT4Attribute : global::System.Attribute
{
    public IndentT4Attribute(string path = """")
    {
    }
}
";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(context =>
        {
            context.CancellationToken.ThrowIfCancellationRequested();
            context.AddSource("Attribute", AttributeSource);
        });

        var filteredTypes = context.SyntaxProvider.CreateSyntaxProvider(Predicate, (context, token) =>
        {
            token.ThrowIfCancellationRequested();
            return context.SemanticModel.GetDeclaredSymbol((context.Node as TypeDeclarationSyntax)!, token);
        }).Where(x => x is not null);

        var projectDir = context.AnalyzerConfigOptionsProvider.Select(SelectProjectDir).WithComparer(StringComparer.Ordinal);
        {
            var attributeT4 = context.CompilationProvider.Select(SelectT4).WithComparer(SymbolEqualityComparer.Default);
            var infoT4s = filteredTypes.Combine(attributeT4.Combine(projectDir)).Select(SelectInfo!).Where(x => x is not null)!.WithComparer(EqualityComparer<Info>.Default);
            context.RegisterSourceOutput(infoT4s, GenerateT4);
        }

        {
            var attributeIndentT4 = context.CompilationProvider.Select(SelectIndentT4).WithComparer(SymbolEqualityComparer.Default);
            var infoIndentT4s = filteredTypes.Combine(attributeIndentT4.Combine(projectDir)).Select(SelectInfo!).Where(x => x is not null)!.WithComparer(EqualityComparer<Info>.Default);
            context.RegisterSourceOutput(infoIndentT4s, GenerateIndentT4);
        }
    }

    private static void GenerateT4(SourceProductionContext context, Info source)
    {
        if (!File.Exists(source.Path))
        {
            return;
        }

        var token = context.CancellationToken;
        token.ThrowIfCancellationRequested();
        var builder = new StringBuilder().AppendLine("// <auto-generated />");
        var text = File.ReadAllText(source.Path, Encoding.UTF8).AsSpan();
        AppendPreprocess(builder, ref text, token);
        GeneratePre(builder, source.Types, source.Namespace, false);
        token.ThrowIfCancellationRequested();
        var indent = (source.Types.Count + 1) << 2;
        while (!text.IsEmpty)
        {
            if (text[0] == '<' && text.Length > 1 && text[1] == '#')
            {
                if (text.Length > 2 && text[2] == '=')
                {
                    text = AppendValue(builder, text.Slice(3).TrimStart(), indent, token);
                }
                else
                {
                    text = AppendCode(builder, text.Slice(2), out _, token);
                }

                continue;
            }

            var index = text.IndexOf("<#".AsSpan(), StringComparison.Ordinal);

            if (index < 0)
            {
                AppendLiteral(builder, text, indent, token);
                text = ReadOnlySpan<char>.Empty;
            }
            else
            {
                AppendLiteral(builder, text.Slice(0, index), indent, token);
                text = text.Slice(index);
            }
        }

        GeneratePost(builder, source.Types);
        var code = builder.ToString();
        context.AddSource(source.HintName, code);
    }

    private static void GenerateIndentT4(SourceProductionContext context, Info source)
    {
        if (!File.Exists(source.Path))
        {
            return;
        }

        var token = context.CancellationToken;
        token.ThrowIfCancellationRequested();
        var builder = new StringBuilder().AppendLine("// <auto-generated />");
        var text = File.ReadAllText(source.Path, Encoding.UTF8).AsSpan();
        AppendPreprocess(builder, ref text, token);
        GeneratePre(builder, source.Types, source.Namespace, true);
        token.ThrowIfCancellationRequested();
        var indent = (source.Types.Count + 1) << 2;
        var shouldIndent = true;
        while (!text.IsEmpty)
        {
            if (text[0] == '<' && text.Length > 1 && text[1] == '#')
            {
                if (text.Length > 2 && text[2] == '=')
                {
                    if (shouldIndent)
                    {
                        PreIndent(builder, indent);
                        shouldIndent = false;
                    }

                    text = AppendValue(builder, text.Slice(3).TrimStart(), indent, token);
                }
                else
                {
                    text = AppendCode(builder, text.Slice(2), out var crlf, token);
                    if (crlf)
                    {
                        shouldIndent = true;
                    }
                }

                continue;
            }

            var index = text.IndexOf("<#".AsSpan(), StringComparison.Ordinal);
            var anotherIndex = text.IndexOfAny('\r', '\n');
            if (anotherIndex < 0)
            {
                if (index == 0)
                {
                    continue;
                }

                if (shouldIndent)
                {
                    PreIndent(builder, indent);
                    shouldIndent = false;
                }

                AppendLiteral(builder, text.Slice(0, index), indent, token);
                text = text.Slice(index);
                continue;
            }

            if (anotherIndex < index)
            {
                if (text[anotherIndex] == '\r' && anotherIndex + 1 < text.Length && text[anotherIndex + 1] == '\n')
                {
                    if (anotherIndex == 0)
                    {
                        AppendLine(builder, indent);
                    }
                    else
                    {
                        if (shouldIndent)
                        {
                            PreIndent(builder, indent);
                        }

                        AppendLineLiteral(builder, text.Slice(0, anotherIndex), indent, token);
                    }

                    text = text.Slice(anotherIndex + 2);
                }
                else
                {
                    if (anotherIndex != 0)
                    {
                        if (shouldIndent)
                        {
                            PreIndent(builder, indent);
                        }

                        AppendLineLiteral(builder, text.Slice(0, anotherIndex), indent, token);
                    }
                    else
                    {
                        AppendLine(builder, indent);
                    }

                    text = text.Slice(anotherIndex + 1);
                }

                shouldIndent = true;
                continue;
            }

            if (shouldIndent)
            {
                PreIndent(builder, indent);
                shouldIndent = false;
            }

            if (index < 0)
            {
                AppendLiteral(builder, text, indent, token);
                text = ReadOnlySpan<char>.Empty;
            }
            else
            {
                AppendLiteral(builder, text.Slice(0, index), indent, token);
                text = text.Slice(index);
            }
        }

        GeneratePost(builder, source.Types);
        var code = builder.ToString();
        context.AddSource(source.HintName, code);
    }

    private static void AppendLiteral(StringBuilder builder, ReadOnlySpan<char> text, int indent, CancellationToken token)
    {
        builder.Append(' ', indent);
        builder.Append("builder.Append(@\"");
        foreach (var c in text)
        {
            token.ThrowIfCancellationRequested();
            if (c == '"')
            {
                builder.Append('"', 2);
            }
            else
            {
                builder.Append(c);
            }
        }

        builder.AppendLine("\");");
    }

    private static void AppendLineLiteral(StringBuilder builder, ReadOnlySpan<char> text, int indent, CancellationToken token)
    {
        builder.Append(' ', indent);
        builder.Append("builder.AppendLine(@\"");
        foreach (var c in text)
        {
            token.ThrowIfCancellationRequested();
            if (c == '"')
            {
                builder.Append('"', 2);
            }
            else
            {
                builder.Append(c);
            }
        }

        builder.AppendLine("\");");
    }

    private static void AppendLine(StringBuilder builder, int indent)
    {
        builder.Append(' ', indent);
        builder.Append("builder.AppendLine();");
    }

    private static void PreIndent(StringBuilder builder, int indent)
    {
        builder.Append(' ', indent).AppendLine("if (indent > 0) builder.Append(' ', indent);");
    }

    private static ReadOnlySpan<char> AppendCode(StringBuilder builder, ReadOnlySpan<char> text, out bool crlf, CancellationToken token)
    {
        crlf = false;
        for (var i = 0; i < text.Length; i++)
        {
            var c = text[i];
            switch (c)
            {
                case '#' when i + 1 < text.Length && text[i + 1] == '>':
                    builder.AppendLine();
                    text = text.Slice(i + 2);
                    if (text.Length >= 2 && text[0] == '\r' && text[1] == '\n')
                    {
                        text = text.Slice(2);
                        crlf = true;
                    }
                    else if (text.Length >= 1 && text[0] == '\n')
                    {
                        text = text.Slice(1);
                        crlf = true;
                    }

                    return text;
                default:
                    token.ThrowIfCancellationRequested();
                    builder.Append(c);
                    break;
            }
        }

        return ReadOnlySpan<char>.Empty;
    }

    private static ReadOnlySpan<char> AppendValue(StringBuilder builder, ReadOnlySpan<char> text, int indent, CancellationToken token)
    {
        builder.Append(' ', indent);
        builder.Append("builder.Append(");
        var endIndex = text.IndexOf("#>".AsSpan(), StringComparison.Ordinal);
        if (endIndex <= 0)
        {
            return ReadOnlySpan<char>.Empty;
        }

        token.ThrowIfCancellationRequested();
        var valueSpan = text.Slice(0, endIndex).TrimEnd();
        foreach (var c in valueSpan)
        {
            builder.Append(c);
        }

        builder.AppendLine(");");
        return text.Slice(endIndex + 2);
    }

    private static void AppendPreprocess(StringBuilder builder, ref ReadOnlySpan<char> text, CancellationToken token)
    {
        var specialStart = "<#@".AsSpan();
        var end = "#>".AsSpan();

        while (!text.IsEmpty)
        {
            token.ThrowIfCancellationRequested();
            if (!text.StartsWith(specialStart))
            {
                break;
            }

            text = text.Slice(specialStart.Length);
            var endIndex = text.IndexOf(end);
            if (endIndex == -1)
            {
                break;
            }

            static bool TryGetUsingNamespace(ReadOnlySpan<char> content, out ReadOnlySpan<char> namespaceSpan)
            {
                var import = "import".AsSpan();
                var namespaceEqualQuotation = "namespace=\"".AsSpan();
                content = content.Trim();
                namespaceSpan = content;

                if (!content.StartsWith(import))
                {
                    return false;
                }

                content = content.Slice(import.Length);
                content = content.TrimStart();

                if (!content.StartsWith(namespaceEqualQuotation))
                {
                    return false;
                }

                content = content.Slice(namespaceEqualQuotation.Length);
                namespaceSpan = content.Slice(0, content.IndexOf('"'));
                return true;
            }

            if (TryGetUsingNamespace(text.Slice(0, endIndex), out var namespaceSpan))
            {
                builder.Append("using ");
                foreach (var c in namespaceSpan)
                {
                    builder.Append(c);
                }

                builder.AppendLine(";");
            }

            text = text.Slice(endIndex + end.Length);
            if (text.Length > 0 && text[0] == '\n')
            {
                text = text.Slice(1);
            }
            else if (text.Length > 1 && text[0] == '\r' && text[1] == '\n')
            {
                text = text.Slice(2);
            }

            continue;
        }

        builder.AppendLine();
    }

    private static void GeneratePre(StringBuilder builder, List<(string Name, bool IsValueType)> types, string? @namespace, bool isIndent)
    {
        if (@namespace != null)
        {
            builder.Append("namespace ");
            builder.Append(@namespace);
            builder.AppendLine(";");
        }

        for (var i = types.Count - 1; i >= 0; i--)
        {
            var (name, isValueType) = types[i];
            var indent = (types.Count - 1 - i) << 2;
            if (indent > 0)
            {
                builder.Append(' ', indent);
            }

            if (isValueType)
            {
                builder.Append("partial struct ");
            }
            else
            {
                builder.Append("partial class ");
            }

            builder.AppendLine(name);
            if (indent > 0)
            {
                builder.Append(' ', indent);
            }

            builder.AppendLine("{");
        }

        builder.Append(' ', types.Count << 2);
        builder.Append("public void TransformAppend(global::System.Text.StringBuilder builder");
        if (isIndent)
        {
            builder.AppendLine(", int indent)");
        }
        else
        {
            builder.AppendLine(")");
        }

        builder.Append(' ', types.Count << 2);
        builder.AppendLine("{");
    }

    private static void GeneratePost(StringBuilder builder, List<(string Name, bool IsValueType)> types)
    {
        builder.Append(' ', types.Count << 2);
        builder.AppendLine("}");
        for (var i = 0; i < types.Count; i++)
        {
            var indent = (types.Count - 1 - i) << 2;
            if (indent > 0)
            {
                builder.Append(' ', indent);
            }

            builder.AppendLine("}");
        }
    }

    private static Info? SelectInfo((INamedTypeSymbol, (INamedTypeSymbol?, string?)) pair, CancellationToken token)
    {
        var (type, (attribute, directory)) = pair;
        if (attribute is null || directory is null)
        {
            return null;
        }

        AttributeData attributeData;
        foreach (var data in type.GetAttributes())
        {
            token.ThrowIfCancellationRequested();
            if (SymbolEqualityComparer.Default.Equals(attribute, data.AttributeClass))
            {
                attributeData = data;
                goto FOUND;
            }
        }

        return null;
FOUND:
        if (attributeData.ConstructorArguments[0].Value is not string path)
        {
            return null;
        }

        var typeName = type.Name;
        if (string.IsNullOrWhiteSpace(path))
        {
            path = Path.Combine(directory, typeName + ".tt");
        }
        else if (path.EndsWith(".tt"))
        {
            path = Path.Combine(directory, path);
        }
        else
        {
            path = Path.Combine(directory, path, typeName + ".tt");
        }

        var list = new List<(string, bool)>
        {
            (type.Name, type.IsValueType),
        };
        for (var itr = type.ContainingType; itr is not null; itr = itr.ContainingType)
        {
            list.Add((itr.Name, itr.IsValueType));
        }

        return new(path, type.ToString(), type.ContainingNamespace?.ToDisplayString(), list);
    }

    private static INamedTypeSymbol? SelectIndentT4(Compilation compilation, CancellationToken token)
    {
        token.ThrowIfCancellationRequested();
        var type = compilation.GetTypeByMetadataName("MessagePackCompiler.IndentT4Attribute");
        return type;
    }

    private static INamedTypeSymbol? SelectT4(Compilation compilation, CancellationToken token)
    {
        token.ThrowIfCancellationRequested();
        var type = compilation.GetTypeByMetadataName("MessagePackCompiler.T4Attribute");
        return type;
    }

    private static bool Predicate(SyntaxNode node, CancellationToken token)
    {
        token.ThrowIfCancellationRequested();
        return node is TypeDeclarationSyntax { AttributeLists.Count: > 0, TypeParameterList: null } and not InterfaceDeclarationSyntax;
    }

    private static string? SelectProjectDir(AnalyzerConfigOptionsProvider provider, CancellationToken token)
    {
        token.ThrowIfCancellationRequested();
        if (!provider.GlobalOptions.TryGetValue("build_property.ProjectDir", out var projectDir))
        {
            return null;
        }

        if (string.IsNullOrWhiteSpace(projectDir))
        {
            return null;
        }

        return projectDir;
    }
}

#pragma warning restore IDE0057
