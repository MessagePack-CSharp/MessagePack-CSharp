<#@ template debug="false" hostspecific="false" linePragmas="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="MessagePack.Analyzers.CodeAnalysis" #>
<#@ import namespace="MessagePack.Analyzers.Transforms" #>

<# if (ResolverNamespace.Length > 0) { #>
namespace <#= ResolverNamespace #>;
<# } #>

using MsgPack = global::MessagePack;

partial class <#= ResolverName #>
{
<# var list = new List<ValueTuple<MemberSerializationInfo, byte[]>>();
	foreach (var member in Info.Members) {
		var binary = EmbedStringHelper.Utf8.GetBytes(member.StringKey);
		list.Add(new ValueTuple<MemberSerializationInfo, byte[]>(member, binary));
	}

	bool isFormatterResolverNecessary = ShouldUseFormatterResolverHelper.ShouldUseFormatterResolver(Info.Members); #>
	private sealed class <#= Info.FormatterName #> : global::MessagePack.Formatters.IMessagePackFormatter<<#= Info.FullName #>>
<# foreach (var typeArg in Info.GenericTypeParameters.Where(x => x.HasConstraints)) {#>
		where <#= typeArg.Name #> : <#= typeArg.Constraints #>
<# }#>
	{
<# foreach (var item in Info.Members) { #>
<# if (item.CustomFormatterTypeName != null) { #>
		private readonly <#= item.CustomFormatterTypeName #> __<#= item.Name #>CustomFormatter__ = new <#= item.CustomFormatterTypeName #>();
<# } #>
<# } #>
<# for (var i = 0; i < list.Count; i++) {
		var member = list[i].Item1;
		var binary = list[i].Item2; #>
		// <#= member.StringKey #>
		private static global::System.ReadOnlySpan<byte> GetSpan_<#= member.Name #>() => <#= EmbedStringHelper.ToByteArrayString(binary) #>;
<# } #>
<# if (list.Count != 0) { #>

<# } #>
		public void Serialize(ref global::MessagePack.MessagePackWriter writer, <#= Info.FullName #> value, global::MessagePack.MessagePackSerializerOptions options)
		{
<# if (Info.IsClass) { #>
			if (value is null)
			{
				writer.WriteNil();
				return;
			}

<# }

	if (isFormatterResolverNecessary) { #>
			var formatterResolver = options.Resolver;
<# }

	if (Info.HasIMessagePackSerializationCallbackReceiver) {
		if (Info.NeedsCastOnBefore) { #>
			((global::MessagePack.IMessagePackSerializationCallbackReceiver)value).OnBeforeSerialize();
<# } else { #>
			value.OnBeforeSerialize();
<# } #>
<# } #>
			writer.WriteMapHeader(<#= list.Count #>);
<# foreach (var memberAndBinary in list) {
		var member = memberAndBinary.Item1; #>
			writer.WriteRaw(GetSpan_<#= member.Name #>());
			<#= member.GetSerializeMethodString() #>;
<# } #>
		}

		public <#= Info.FullName #> Deserialize(ref global::MessagePack.MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
		{
			if (reader.TryReadNil())
			{
<# if (Info.IsClass) { #>
				return null;
<# } else { #>
				throw new global::System.InvalidOperationException("typecode is null, struct not supported");
<# } #>
			}

<# if (Info.Members.Length == 0) { #>
			reader.Skip();
			var ____result = new <#= Info.GetConstructorString() #>;
<# } else { #>
			options.Security.DepthStep(ref reader);
<# if (isFormatterResolverNecessary) { #>
			var formatterResolver = options.Resolver;
<# } #>
			var length = reader.ReadMapHeader();
<# var canOverwrite = Info.ConstructorParameters.Length == 0;
		if (canOverwrite) { #>
			var ____result = new <#= Info.GetConstructorString() #>;
<# } else {
			foreach (var member in Info.Members.Where(x => x.IsWritable || Info.ConstructorParameters.Any(p => p.Equals(x)))) { #>
<# if (Info.ConstructorParameters.All(p => !p.Equals(member))) { #>
			var __<#= member.Name #>__IsInitialized = false;
<# } #>
			var __<#= member.Name #>__ = default(<#= member.Type #>);
<# } #>
<# } #>

			for (int i = 0; i < length; i++)
			{
				var stringKey = global::MessagePack.Internal.CodeGenHelpers.ReadStringSpan(ref reader);
				switch (stringKey.Length)
				{
					default:
					FAIL:
					  reader.Skip();
					  continue;
<#= StringKeyFormatterDeserializeHelper.Classify(Info, "					", canOverwrite) #>
				}
			}

<# if (!canOverwrite) { #>
			var ____result = new <#= Info.GetConstructorString() #>;
<# foreach (var member in Info.Members.Where(x => x.IsWritable && !Info.ConstructorParameters.Any(p => p.Equals(x)))) { #>
			if (__<#= member.Name #>__IsInitialized)
			{
				____result.<#= member.Name #> = __<#= member.Name #>__;
			}

<# } #>
<# } #>
<# } #>
<# if (Info.HasIMessagePackSerializationCallbackReceiver) {
		if (Info.NeedsCastOnAfter) { #>
			((global::MessagePack.IMessagePackSerializationCallbackReceiver)____result).OnAfterDeserialize();
<# } else { #>
			____result.OnAfterDeserialize();
<# } #>
<# } #>
<# if (Info.Members.Length != 0) { #>
			reader.Depth--;
<# } #>
			return ____result;
		}
	}
}
