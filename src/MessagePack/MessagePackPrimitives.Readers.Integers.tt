<#@ assembly name="System.Core" #>
<#@ Import Namespace="System.Linq" #>
// Copyright (c) All contributors. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

/* THIS (.cs) FILE IS GENERATED. DO NOT CHANGE IT.
 * CHANGE THE .tt FILE INSTEAD. */

using System;
using System.Buffers;

#pragma warning disable SA1205 // Partial elements should declare access

namespace MessagePack;

partial class MessagePackPrimitives
{<#
var allTypes = new Type[] { typeof(byte), typeof(ushort), typeof(uint), typeof(ulong), typeof(sbyte), typeof(short), typeof(int), typeof(long) }.Select(t => t.Name);
foreach (var intType in allTypes) {
#>

    /// <summary>
    /// Tries to read an <see cref="<#=intType#>"/> value from:
    /// Some value between <see cref="MessagePackCode.MinNegativeFixInt"/> and <see cref="MessagePackCode.MaxNegativeFixInt"/>,
    /// Some value between <see cref="MessagePackCode.MinFixInt"/> and <see cref="MessagePackCode.MaxFixInt"/>,
    /// or any of the other MsgPack integer types.
    /// </summary>
    /// <returns>The value.</returns>
    /// <exception cref="OverflowException">Thrown when the value exceeds what can be stored in the returned type.</exception>
    public static ReadResult TryRead<#=intType#>(ReadOnlySpan<byte> source, out <#=intType#> value, out int tokenSize)
    {
        tokenSize = 1;
        if (source.Length == 0)
        {
            value = 0;
            return ReadResult.EmptyBuffer;
        }

        switch (source[0])
        {
            case MessagePackCode.UInt8:
                tokenSize = 2;
                if (source.Length < tokenSize)
                {
                    value = 0;
                    return ReadResult.InsufficientBuffer;
                }

                value = checked((<#=intType#>)source[1]);
                return ReadResult.Success;
            case MessagePackCode.Int8:
                tokenSize = 2;
                if (source.Length < tokenSize)
                {
                    value = 0;
                    return ReadResult.InsufficientBuffer;
                }

                value = checked((<#=intType#>)unchecked((sbyte)source[1]));
                return ReadResult.Success;
            case MessagePackCode.UInt16:
                tokenSize = 3;
                if (!TryReadBigEndian(source.Slice(1), out ushort ushortResult))
                {
                    value = 0;
                    return ReadResult.InsufficientBuffer;
                }

                value = checked((<#=intType#>)ushortResult);
                return ReadResult.Success;
            case MessagePackCode.Int16:
                tokenSize = 3;
                if (!TryReadBigEndian(source.Slice(1), out short shortResult))
                {
                    value = 0;
                    return ReadResult.InsufficientBuffer;
                }

                value = checked((<#=intType#>)shortResult);
                return ReadResult.Success;
            case MessagePackCode.UInt32:
                tokenSize = 5;
                if (!TryReadBigEndian(source.Slice(1), out uint uintResult))
                {
                    value = 0;
                    return ReadResult.InsufficientBuffer;
                }

                value = checked((<#=intType#>)uintResult);
                return ReadResult.Success;
            case MessagePackCode.Int32:
                tokenSize = 5;
                if (!TryReadBigEndian(source.Slice(1), out int intResult))
                {
                    value = 0;
                    return ReadResult.InsufficientBuffer;
                }

                value = checked((<#=intType#>)intResult);
                return ReadResult.Success;
            case MessagePackCode.UInt64:
                tokenSize = 9;
                if (!TryReadBigEndian(source.Slice(1), out ulong ulongResult))
                {
                    value = 0;
                    return ReadResult.InsufficientBuffer;
                }

                value = checked((<#=intType#>)ulongResult);
                return ReadResult.Success;
            case MessagePackCode.Int64:
                tokenSize = 9;
                if (!TryReadBigEndian(source.Slice(1), out long longResult))
                {
                    value = 0;
                    return ReadResult.InsufficientBuffer;
                }

                value = checked((<#=intType#>)longResult);
                return ReadResult.Success;
            case >= MessagePackCode.MinNegativeFixInt and <= MessagePackCode.MaxNegativeFixInt:
                value = checked((<#=intType#>)unchecked((sbyte)source[0]));
                return ReadResult.Success;
            case >= MessagePackCode.MinFixInt and <= MessagePackCode.MaxFixInt:
                value = (<#=intType#>)source[0];
                return ReadResult.Success;
            default:
                value = 0;
                return ReadResult.TokenMismatch;
        }
    }
<# }
var floatingPointTypes = new Type[] { typeof(float), typeof(double) }.Select(t => t.Name);
foreach (var floatType in floatingPointTypes) { #>

    /// <summary>
    /// Tries to read an <see cref="<#=floatType#>"/> value from a <see cref="MessagePackCode.Float64"/> or <see cref="MessagePackCode.Float32"/>
    /// or any of the integer types.
    /// </summary>
    /// <returns>The value.</returns>
    /// <exception cref="OverflowException">Thrown when the value exceeds what can be stored in the returned type.</exception>
    public static unsafe ReadResult TryRead<#=floatType#>(ReadOnlySpan<byte> source, out <#=floatType#> value, out int tokenSize)
    {
        tokenSize = 1;
        if (source.Length < 1)
        {
            value = default;
            return ReadResult.EmptyBuffer;
        }

        switch (source[0])
        {
            case MessagePackCode.Float32:
                tokenSize = 5;
                if (source.Length < tokenSize)
                {
                    value = default;
                    return ReadResult.InsufficientBuffer;
                }

                AssumesTrue(TryReadBigEndian(source.Slice(1), out uint uintValue));
                value = *(float*)&uintValue;
                return ReadResult.Success;
            case MessagePackCode.Float64:
                tokenSize = 9;
                if (source.Length < tokenSize)
                {
                    value = default;
                    return ReadResult.InsufficientBuffer;
                }

                AssumesTrue(TryReadBigEndian(source.Slice(1), out ulong ulongValue));
                value = (<#=floatType#>)(*(double*)&ulongValue);
                return ReadResult.Success;
            case MessagePackCode.Int8 or MessagePackCode.Int16 or MessagePackCode.Int32 or MessagePackCode.Int64:
            case >= MessagePackCode.MinNegativeFixInt and <= MessagePackCode.MaxNegativeFixInt:
                ReadResult result = TryReadInt64(source, out long longValue, out tokenSize);
                value = longValue;
                return result;
            case MessagePackCode.UInt8 or MessagePackCode.UInt16 or MessagePackCode.UInt32 or MessagePackCode.UInt64:
            case >= MessagePackCode.MinFixInt and <= MessagePackCode.MaxFixInt:
                result = TryReadUInt64(source, out ulongValue, out tokenSize);
                value = ulongValue;
                return result;
            default:
                value = default;
                return ReadResult.TokenMismatch;
        }
    }
<# } #>
}
