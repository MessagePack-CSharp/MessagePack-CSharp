<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
// Copyright (c) All contributors. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Runtime.Intrinsics;

namespace MessagePack.Formatters;

internal static partial class ReadOnlySpanSerializeHelper
{
    internal static void Serialize(ref MessagePackWriter writer, ref readonly float input, int length)
    {
        writer.WriteArrayHeader(length);
        if (length == 0)
        {
            return;
        }

        if (!BitConverter.IsLittleEndian)
        {
            BigEndianSerialize(ref writer, ref Unsafe.AsRef(in input), length, writer.CancellationToken);
            return;
        }

        ref var inputIterator = ref Unsafe.As<float, uint>(ref Unsafe.AsRef(in input));
        const int maxInputSize = int.MaxValue / (sizeof(float) + 1);
<#
var array = new int[] { 16, 8, 4 };
for (int i = 0; i < array.Length; i++)
{
    var Count = array[i];
    var BitWidth = Count * sizeof(float) * 8;
#>
        <#if (i != 0){#>else <#}#>if (Vector<#= BitWidth #>.IsHardwareAccelerated)
        {
            for (var alignedInputLength = (nuint)(length & (~<#= Count - 1 #>)); alignedInputLength > 0; alignedInputLength = (nuint)(length & (~<#= Count - 1 #>)))
            {
                if (alignedInputLength >= maxInputSize)
                {
                    alignedInputLength = maxInputSize & (~<#= Count - 1 #>);
                }

                var outputLength = (int)alignedInputLength * (sizeof(float) + 1);
                var destination = writer.GetSpan(outputLength);
                ref var outputIterator = ref MemoryMarshal.GetReference(destination);
                for (nuint inputOffset = 0, outputOffset = 0; inputOffset < alignedInputLength; inputOffset += (nuint)Vector<#= BitWidth #><uint>.Count, outputOffset += (nuint)Vector<#= BitWidth #><uint>.Count * (sizeof(float) + 1))
                {
                    writer.CancellationToken.ThrowIfCancellationRequested();

                    // Reorder Little Endian bytes to Big Endian.
                    var shuffled = Vector<#= BitWidth #>.Shuffle(Vector<#= BitWidth #>.LoadUnsafe(ref inputIterator, inputOffset).AsByte(), Vector<#= BitWidth #>.Create(<# for (int j = 0; j * 8 < BitWidth; j += 16) { if (j == 0) { #>(byte)<# } else { #>, <# } #><#= j + 3 #>, <#= j + 2 #>, <#= j + 1 #>, <#= j #>, <#= j + 7 #>, <#= j + 6 #>, <#= j + 5 #>, <#= j + 4 #>, <#= j + 11 #>, <#= j + 10 #>, <#= j + 9 #>, <#= j + 8 #>, <#= j + 15 #>, <#= j + 14 #>, <#= j + 13 #>, <#= j + 12 #><# } #>)).AsUInt<#= sizeof(float) * 8 #>();

                    // Write <#= Count #> Big-Endian floats.
<#for (int j = 0; j < Count; j++)
  {
#>
                    WriteFloat<#= sizeof(float) * 8 #>(ref Unsafe.AddByteOffset(ref outputIterator, outputOffset<# if (j != 0) { #> + <#= j * (sizeof(float) + 1) #><# } #>), shuffled.GetElement(<#= j #>));
<#}#>
                }

                writer.Advance(outputLength);
                length -= (int)alignedInputLength;
                inputIterator = ref Unsafe.Add(ref inputIterator, alignedInputLength);
            }
        }
<#}#>

        while (length > 0)
        {
            var inputLength = length;
            if (inputLength > maxInputSize)
            {
                inputLength = maxInputSize;
            }

            var outputLength = inputLength * (sizeof(float) + 1);
            var destination = writer.GetSpan(outputLength);
            ref var outputIterator = ref MemoryMarshal.GetReference(destination);
            for (nuint index = 0; index < (nuint)inputLength; index++)
            {
                writer.CancellationToken.ThrowIfCancellationRequested();
                outputIterator = ref ReverseWriteFloat<#= sizeof(float) * 8 #>(ref outputIterator, Unsafe.Add(ref inputIterator, index));
            }

            length -= inputLength;
            writer.Advance(outputLength);
        }
    }
}
