<#@ template debug="false" hostspecific="false" linePragmas="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="MessagePackCompiler.CodeAnalysis" #>
// <auto-generated>
// THIS (.cs) FILE IS GENERATED BY MPC(MessagePack-CSharp). DO NOT CHANGE IT.
// </auto-generated>

#pragma warning disable 618
#pragma warning disable 612
#pragma warning disable 414
#pragma warning disable 168

#pragma warning disable SA1129 // Do not use default value type constructor
#pragma warning disable SA1200 // Using directives should be placed correctly
#pragma warning disable SA1309 // Field names should not begin with underscore
#pragma warning disable SA1312 // Variable names should begin with lower-case letter
#pragma warning disable SA1403 // File may only contain a single namespace
#pragma warning disable SA1649 // File name should match first type name

namespace <#= Namespace #>
{
    using System;
    using System.Buffers;
    using System.Runtime.InteropServices;
    using MessagePack;

<#
foreach(var objInfo in ObjectSerializationInfos)
{
    string formatterName = objInfo.Name + (objInfo.IsOpenGenericType ? $"Formatter<{string.Join(",", objInfo.GenericTypeParameters)}>" : "Formatter");
    bool isFormatterResolverNecessary = ShouldUseFormatterResolverHelper.ShouldUseFormatterResolver(objInfo.Members);
#>
    public sealed class <#= formatterName #> : global::MessagePack.Formatters.IMessagePackFormatter<<#= objInfo.FullName #>>
    {
        public void Serialize(ref MessagePackWriter writer, <#= objInfo.FullName #> value, global::MessagePack.MessagePackSerializerOptions options)
        {
<#
    if( objInfo.IsClass)
    {#>
            if (value == null)
            {
                writer.WriteNil();
                return;
            }

<#
    }

    if (isFormatterResolverNecessary)
    {#>
            var formatterResolver = options.Resolver;
<#
    }

    if(objInfo.HasIMessagePackSerializationCallbackReceiver && objInfo.NeedsCastOnBefore)
    {#>
            ((IMessagePackSerializationCallbackReceiver)value).OnBeforeSerialize();
<#  }
  else if(objInfo.HasIMessagePackSerializationCallbackReceiver)
  {#>
            value.OnBeforeSerialize();
<#  }#>
            writer.WriteMapHeader(<#= objInfo.WriteCount #>);
<#
    for (int i = 0; i < objInfo.Members.Length; i++)
    {
        var member = objInfo.Members[i];
        var rawBytes = EmbedStringHelper.GetEncodedStringBytes(member.StringKey);#>
            // <#= member.StringKey #>
            writer.WriteRaw(<#= StringKeyFormatterGeneratorHelper.ToStringNewByteArray(rawBytes) #>);
            <#= member.GetSerializeMethodString() #>;
<#
    }#>
        }

        public <#= objInfo.FullName #> Deserialize(ref MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
        {
            if (reader.TryReadNil())
            {
<#
    if (objInfo.IsClass)
    {#>
                return null;
<#    }
    else
    {#>
                throw new InvalidOperationException("typecode is null, struct not supported");
<#    }#>
            }

            options.Security.DepthStep(ref reader);
<#
    if (isFormatterResolverNecessary)
    {
#>
            var formatterResolver = options.Resolver;
<#
    }

    var members = StringKeyFormatterGeneratorHelper.GetSortedStringKeys(objInfo.Members);
    foreach(var memberInfo in objInfo.Members)
    {#>
            var __<#= memberInfo.Name #>__ = default(<#= memberInfo.Type #>);
<#    }

    const string indent = "                        ";
    var lengthEnumerable = new StringKeyLengthGroupEnumerable(members);
    var lessThan8 = lengthEnumerable.TakeWhile(x => x.Span[0].Item1.Length < 8).ToArray();
    var greaterThan7 = lengthEnumerable.SkipWhile(x => x.Span[0].Item1.Length < 8).ToArray();
    if (greaterThan7.Length != 0)
    {#>
            var isBigEndian = !global::System.BitConverter.IsLittleEndian;
<#
    }#>

            for (int i = 0, length = reader.ReadMapHeader(); i < length; i++)
            {
<#
    if(lessThan8.Length == 0)
    {
        if (greaterThan7.Length == 0)
        {#>
                reader.Skip();
                reader.Skip();
<#
        }
        else
        {#>
                var stringKey = global::MessagePack.Internal.CodeGenHelpers.ReadStringSpan(ref reader);
                ReadOnlySpan<ulong> ulongs = isBigEndian ? stackalloc ulong[stringKey.Length >> 3] : MemoryMarshal.Cast<byte, ulong>(stringKey);
                if (isBigEndian)
                {
                    for (var index = 0; index < ulongs.Length; index++)
                    {
                        var index8times = index << 3;
                        ref var number = ref global::System.Runtime.CompilerServices.Unsafe.AsRef(ulongs[index]);
                        number = stringKey[index8times + 7];
                        for (var numberIndex = index8times + 6; numberIndex >= index8times; numberIndex--)
                        {
                            number <<= 8;
                            number |= stringKey[numberIndex];
                        }
                    }
                }

                switch (stringKey.Length)
                {
                    default:
                    FAIL:
                        reader.Skip();
                        continue;
<#
            foreach (var tuple in greaterThan7)
            {
                var (readOnlyMemory, member) = tuple.Span[0];
#>
                    case <#= readOnlyMemory.Length #>:
<#= tuple.EmbedSwitch(readOnlyMemory.Length % 8, indent, readOnlyMemory.Length >> 3) #>
<#
            }#>
                }
<#
        }
    }
    else
    {
        if (greaterThan7.Length == 0)
        {#>
                var stringKey = global::MessagePack.Internal.CodeGenHelpers.ReadStringSpan(ref reader);
                switch (stringKey.Length)
                {
                    default:
                    FAIL:
                        reader.Skip();
                        continue;
<#
            foreach (var tuple in lessThan8)
            {
                var (readOnlyMemory, member) = tuple.Span[0];
#>
                    case <#= readOnlyMemory.Length #>:
<#= tuple.Span.EmbedSwitchLast(readOnlyMemory.Length, indent) #>
<#
            }#>
                }
<#
        }
        else
        {#>
                var stringKey = global::MessagePack.Internal.CodeGenHelpers.ReadStringSpan(ref reader);
                switch (stringKey.Length)
                {
<#
            foreach (var tuple in lessThan8)
            {
                var (readOnlyMemory, member) = tuple.Span[0];
#>
                    case <#= readOnlyMemory.Length #>:
<#= tuple.Span.EmbedSwitchLast(readOnlyMemory.Length, indent) #>
<#
            }#>
                }

                ReadOnlySpan<ulong> ulongs = isBigEndian ? stackalloc ulong[stringKey.Length >> 3] : MemoryMarshal.Cast<byte, ulong>(stringKey);
                if (isBigEndian)
                {
                    for (var index = 0; index < ulongs.Length; index++)
                    {
                        var index8times = index << 3;
                        ref var number = ref global::System.Runtime.CompilerServices.Unsafe.AsRef(ulongs[index]);
                        number = stringKey[index8times + 7];
                        for (var numberIndex = index8times + 6; numberIndex >= index8times; numberIndex--)
                        {
                            number <<= 8;
                            number |= stringKey[numberIndex];
                        }
                    }
                }

                switch (stringKey.Length)
                {
                    default: goto FAIL;
<#
            foreach (var tuple in greaterThan7)
            {
                var (readOnlyMemory, member) = tuple.Span[0];
#>
                    case <#= readOnlyMemory.Length #>:
<#= tuple.EmbedSwitch(readOnlyMemory.Length % 8, indent, readOnlyMemory.Length >> 3) #>
<#
            }#>
                }

            FAIL:
                reader.Skip();
<#
        }
    }
#>
            }

            var ____result = new <#= objInfo.GetConstructorString() #>;
<#
    foreach(var member in objInfo.Members.Where(x => x.IsWritable))
    {#>
            ____result.<#= member.Name #> = __<#= member.Name #>__;
<#
    }
    if(objInfo.HasIMessagePackSerializationCallbackReceiver && objInfo.NeedsCastOnAfter)
    {#>
            ((IMessagePackSerializationCallbackReceiver)____result).OnAfterDeserialize();
<#
    }
    else if(objInfo.HasIMessagePackSerializationCallbackReceiver)
    {#>
            ____result.OnAfterDeserialize();
<#
    }#>
            reader.Depth--;
            return ____result;
        }
    }
<#}#>
}
