<#@ template debug="false" hostspecific="false" linePragmas="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
// <auto-generated>
// THIS (.cs) FILE IS GENERATED BY MPC(MessagePack-CSharp). DO NOT CHANGE IT.
// </auto-generated>

#pragma warning disable 618
#pragma warning disable 612
#pragma warning disable 414
#pragma warning disable 168

#pragma warning disable SA1200 // Using directives should be placed correctly
#pragma warning disable SA1312 // Variable names should begin with lower-case letter
#pragma warning disable SA1649 // File name should match first type name

namespace <#= Namespace #>
{
    using System;
    using System.Buffers;
    using MessagePack;
<# if( UnboundGenericInfo.Length > 0 ) {#>
    using System.Reflection;
    using static System.Diagnostics.Debug;
    using System.Collections.Generic;

    public static class DictionaryExtensions
    {
        //this still does a double look up (one for get, one for Add()), there's no way out of it with the current C# Dictionary
        //https://stackoverflow.com/questions/3705950/combined-check-add-or-fetch-from-dictionary
        public static TValue GetOrAdd<TKey, TValue>( this IDictionary<TKey, TValue> dictionary,
                                            TKey key, Func<TValue> valueCreator )
        {
            TValue value;
            if ( !dictionary.TryGetValue( key, out value ) )
            {
                value = valueCreator();
                dictionary.Add( key, value );
            }
            return value;
        }

        public static TValue GetOrAdd<TKey, TValue>( this IDictionary<TKey, TValue> dictionary,
            TKey key ) where TValue : new()
        {
            return dictionary.GetOrAdd( key, () => new TValue() );
        }
    }
<# } #>

    public class <#= ResolverName #> : global::MessagePack.IFormatterResolver
    {
        public static readonly global::MessagePack.IFormatterResolver Instance = new <#= ResolverName #>();

<# if( UnboundGenericInfo.Length > 0 ){ #>
        static readonly Dictionary<Type, Type> genericTypeDefToFormatterTypeDef = new Dictionary<Type, Type>( <#= UnboundGenericInfo.Length #> )
        {
<# for(var i = 0; i < UnboundGenericInfo.Length; i++) { 
    string emptyAngularBrackets = UnboundGenericInfo[ i ].TemplateParametersEmpty;
#>
            { typeof( <#= UnboundGenericInfo[ i ].FullNameNoGenericParams#> <#=emptyAngularBrackets #>), 
                typeof( <#= UnboundGenericInfo[ i ].FormatterName.StartsWith("global::") ? UnboundGenericInfo[ i ].FormatterName: (!string.IsNullOrEmpty(FormatterNamespace) ? FormatterNamespace + "." : FormatterNamespace) + 
                    UnboundGenericInfo[ i ].FormatterName#> <#=emptyAngularBrackets #> ) },

<# } #>
            };

            static Dictionary<Type, object> closedGenericFormatterCache = new Dictionary<Type, object>();

<# } #>
        private <#= ResolverName #>()
        {
        }

        public global::MessagePack.Formatters.IMessagePackFormatter<T> GetFormatter<T>()
        {
<# if( UnboundGenericInfo.Length == 0 ){ #>
            return FormatterCache<T>.Formatter;
<# } else{ #>
            global::MessagePack.Formatters.IMessagePackFormatter<T> formatter =
                FormatterCache<T>.Formatter;

            if ( formatter == null )
            {
                Type type = typeof( T );
                TypeInfo typeInfo = type.GetTypeInfo();
                if ( typeInfo.IsGenericType )
                {
                    Assert( type.IsConstructedGenericType );
                    Assert( !typeInfo.IsGenericTypeDefinition );
                    Assert( !typeInfo.ContainsGenericParameters );
                    Type genericTypeDef = type.GetGenericTypeDefinition();
                    Type genericFormatterTypeDef;
                    if ( !genericTypeDefToFormatterTypeDef.TryGetValue( genericTypeDef, out genericFormatterTypeDef ) )
                    {
                        formatter = null;
                    }
                    else
                    {
                        Type closedFormatterType = genericFormatterTypeDef.MakeGenericType( type.GenericTypeArguments );

                        formatter = ( global::MessagePack.Formatters.IMessagePackFormatter<T> )
                            closedGenericFormatterCache.GetOrAdd( closedFormatterType,
                                () => Activator.CreateInstance( closedFormatterType ) );
                    }

                }
            }

            return formatter;

<# } #>
        }

        private static class FormatterCache<T>
        {
            internal static readonly global::MessagePack.Formatters.IMessagePackFormatter<T> Formatter;

            static FormatterCache()
            {
                var f = <#= ResolverName #>GetFormatterHelper.GetFormatter(typeof(T));
                if (f != null)
                {
                    Formatter = (global::MessagePack.Formatters.IMessagePackFormatter<T>)f;
                }
            }
        }
    }

    internal static class <#= ResolverName #>GetFormatterHelper
    {
        private static readonly global::System.Collections.Generic.Dictionary<Type, int> lookup;

        static <#= ResolverName #>GetFormatterHelper()
        {
            lookup = new global::System.Collections.Generic.Dictionary<Type, int>(<#= RegisterInfos.Length #>)
            {
<# for(var i = 0; i < RegisterInfos.Length; i++) { var x = RegisterInfos[i]; #>
                { typeof(<#= x.FullName #>), <#= i #> },
<# } #>
            };
        }

        internal static object GetFormatter(Type t)
        {
            int key;
            if (!lookup.TryGetValue(t, out key))
            {
                return null;
            }

            switch (key)
            {
<# for(var i = 0; i < RegisterInfos.Length; i++) { var x = RegisterInfos[i]; #>
                case <#= i #>: return new <#= x.FormatterName.StartsWith("global::") ? x.FormatterName: (!string.IsNullOrEmpty(FormatterNamespace) ? FormatterNamespace + "." : FormatterNamespace) + x.FormatterName#>();
<# } #>
                default: return null;
            }
        }
    }
}

#pragma warning restore 168
#pragma warning restore 414
#pragma warning restore 618
#pragma warning restore 612

#pragma warning restore SA1312 // Variable names should begin with lower-case letter
#pragma warning restore SA1200 // Using directives should be placed correctly
#pragma warning restore SA1649 // File name should match first type name
