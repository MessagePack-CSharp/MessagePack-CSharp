<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#
var types = new Type[]
{
    typeof(sbyte),
    typeof(short),
    typeof(int),
    typeof(long),
    typeof(ushort),
    typeof(uint),
    typeof(ulong),
    typeof(float),
    typeof(double),
    typeof(bool),
};
#>
// Copyright (c) All contributors. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

extern alias e;

using System;
using System.Buffers;
using System.Runtime.InteropServices;
using NUnit.Framework;

namespace MessagePack.Experimental.Tests;

public class ArrayTests
{<#
foreach (var type in types)
{
    var name = type.Name;
#>

    private static readonly MessagePack.Formatters.ArrayFormatter<<#= name #>> <#= name #>ArrayFormatter = new();

    [Test]
    public void Empty<#= name #>ArrayTests()
    {
        var array = Array.Empty<<#= name #>>();
        ArrayBufferWriter<byte> bufferWriter = new();
        {
            MessagePackWriter writer = new(bufferWriter);
            e::MessagePack.Formatters.<#= name #>ArrayFormatter.Instance.Serialize(ref writer, array, default!);
            writer.Flush();
        }

        var encoded = bufferWriter.WrittenMemory.ToArray();
        Assert.IsNotNull(encoded);

        MessagePackReader reader = new(encoded);
        <#= name #>[]? decoded = e::MessagePack.Formatters.<#= name #>ArrayFormatter.Instance.Deserialize(ref reader, default!);
        Assert.IsNotNull(decoded);
        Assert.AreEqual(0, decoded!.Length);
    }

    [Test]
    public void Null<#= name #>ArrayTests()
    {
        var array = default(<#= name #>[]);
        ArrayBufferWriter<byte> bufferWriter = new();
        {
            MessagePackWriter writer = new(bufferWriter);
            e::MessagePack.Formatters.<#= name #>ArrayFormatter.Instance.Serialize(ref writer, array, default!);
            writer.Flush();
        }

        var encoded = bufferWriter.WrittenMemory.ToArray();
        Assert.IsNotNull(encoded);
        MessagePackReader reader = new(encoded);
        <#= name #>[]? decoded = e::MessagePack.Formatters.<#= name #>ArrayFormatter.Instance.Deserialize(ref reader, default!);
        Assert.IsNull(decoded);
    }

    [TestCase(1)]
    [TestCase(8)]
    [TestCase(16)]
    [TestCase(32)]
    [TestCase(128)]
    [TestCase(4096)]
    public void Default<#= name #>ArrayTests(int length)
    {
        var array = new <#= name #>[length];
        ArrayBufferWriter<byte> bufferWriter = new();
        {
            MessagePackWriter writer = new(bufferWriter);
            e::MessagePack.Formatters.<#= name #>ArrayFormatter.Instance.Serialize(ref writer, array, default!);
            writer.Flush();
        }

        var encoded = bufferWriter.WrittenMemory.ToArray();
        Assert.IsNotNull(encoded);

        bufferWriter.Clear();
        {
            MessagePackWriter writer = new(bufferWriter);
            <#= name #>ArrayFormatter.Serialize(ref writer, array, default!);
            writer.Flush();
        }

        var defaultEncoded = bufferWriter.WrittenMemory.ToArray();
        Assert.AreEqual(encoded.Length, defaultEncoded.Length);
        Assert.That(encoded.AsSpan().SequenceEqual(defaultEncoded));
        MessagePackReader reader = new(encoded);
        <#= name #>[]? decoded = e::MessagePack.Formatters.<#= name #>ArrayFormatter.Instance.Deserialize(ref reader, default!);
        Assert.IsNotNull(decoded);
        Assert.That(decoded.AsSpan().SequenceEqual(array));
    }
<#
    if (type != typeof(bool))
    {
#>

    [TestCase(1)]
    [TestCase(8)]
    [TestCase(16)]
    [TestCase(32)]
    [TestCase(128)]
    [TestCase(4096)]
    public void MinValue<#= name #>ArrayTests(int length)
    {
        var array = new <#= name #>[length];
        for (var index = 0; index < array.Length; index++)
        {
            array[index] = <#= name #>.MinValue;
        }

        ArrayBufferWriter<byte> bufferWriter = new();
        {
            MessagePackWriter writer = new(bufferWriter);
            e::MessagePack.Formatters.<#= name #>ArrayFormatter.Instance.Serialize(ref writer, array, default!);
            writer.Flush();
        }

        var encoded = bufferWriter.WrittenMemory.ToArray();
        Assert.IsNotNull(encoded);

        bufferWriter.Clear();
        {
            MessagePackWriter writer = new(bufferWriter);
            <#= name #>ArrayFormatter.Serialize(ref writer, array, default!);
            writer.Flush();
        }

        var defaultEncoded = bufferWriter.WrittenMemory.ToArray();
        Assert.AreEqual(encoded.Length, defaultEncoded.Length);
        Assert.That(encoded.AsSpan().SequenceEqual(defaultEncoded));
        MessagePackReader reader = new(encoded);
        <#= name #>[]? decoded = e::MessagePack.Formatters.<#= name #>ArrayFormatter.Instance.Deserialize(ref reader, default!);
        Assert.IsNotNull(decoded);
        Assert.That(decoded.AsSpan().SequenceEqual(array));
    }
<#
    }
#>
<#
    if (type == typeof(float) || type == typeof(double))
    {
#>

    [TestCase(1)]
    [TestCase(8)]
    [TestCase(16)]
    [TestCase(32)]
    [TestCase(128)]
    [TestCase(4096)]
    public void RandomValue<#= name #>ArrayTests(int length)
    {
        var array = new <#= name #>[length];
        for (var index = 0; index < array.Length; index++)
        {
            array[index] = Random.Shared.Next<#= name #>();
        }

        ArrayBufferWriter<byte> bufferWriter = new();
        {
            MessagePackWriter writer = new(bufferWriter);
            e::MessagePack.Formatters.<#= name #>ArrayFormatter.Instance.Serialize(ref writer, array, default!);
            writer.Flush();
        }

        var encoded = bufferWriter.WrittenMemory.ToArray();
        Assert.IsNotNull(encoded);

        bufferWriter.Clear();
        {
            MessagePackWriter writer = new(bufferWriter);
            <#= name #>ArrayFormatter.Serialize(ref writer, array, default!);
            writer.Flush();
        }

        var defaultEncoded = bufferWriter.WrittenMemory.ToArray();
        Assert.AreEqual(encoded.Length, defaultEncoded.Length);
        Assert.That(encoded.AsSpan().SequenceEqual(defaultEncoded));
        MessagePackReader reader = new(encoded);
        <#= name #>[]? decoded = e::MessagePack.Formatters.<#= name #>ArrayFormatter.Instance.Deserialize(ref reader, default!);
        Assert.IsNotNull(decoded);
        Assert.That(decoded.AsSpan().SequenceEqual(array));
    }
<#
    }
#>
<#
    if (type != typeof(float) && type != typeof(double) && type != typeof(bool))
    {
#>

    [TestCase(1)]
    [TestCase(8)]
    [TestCase(16)]
    [TestCase(32)]
    [TestCase(128)]
    [TestCase(4096)]
    public void RandomValue<#= name #>ArrayTests(int length)
    {
        var array = new <#= name #>[length];
        var r = new Random();
        r.NextBytes(MemoryMarshal.AsBytes(array.AsSpan()));

        ArrayBufferWriter<byte> bufferWriter = new();
        {
            MessagePackWriter writer = new(bufferWriter);
            e::MessagePack.Formatters.<#= name #>ArrayFormatter.Instance.Serialize(ref writer, array, default!);
            writer.Flush();
        }

        var encoded = bufferWriter.WrittenMemory.ToArray();
        Assert.IsNotNull(encoded);

        bufferWriter.Clear();
        {
            MessagePackWriter writer = new(bufferWriter);
            <#= name #>ArrayFormatter.Serialize(ref writer, array, default!);
            writer.Flush();
        }

        var defaultEncoded = bufferWriter.WrittenMemory.ToArray();
        Assert.AreEqual(encoded.Length, defaultEncoded.Length);
        Assert.That(encoded.AsSpan().SequenceEqual(defaultEncoded));
        MessagePackReader reader = new(encoded);
        <#= name #>[]? decoded = e::MessagePack.Formatters.<#= name #>ArrayFormatter.Instance.Deserialize(ref reader, default!);
        Assert.IsNotNull(decoded);
        Assert.AreEqual(length, decoded!.Length);
        Assert.That(decoded.AsSpan().SequenceEqual(array));
    }
<#
    }
#>
<#
}
#>
}
